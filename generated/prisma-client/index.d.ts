// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  data: (where?: DataWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  inode: (where?: InodeWhereInput) => Promise<boolean>;
  metadata: (where?: MetadataWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  permissionSet: (where?: PermissionSetWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  data: (where: DataWhereUniqueInput) => DataPromise;
  datas: (
    args?: {
      where?: DataWhereInput;
      orderBy?: DataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Data>;
  datasConnection: (
    args?: {
      where?: DataWhereInput;
      orderBy?: DataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DataConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Group>;
  groupsConnection: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GroupConnectionPromise;
  inode: (where: InodeWhereUniqueInput) => InodePromise;
  inodes: (
    args?: {
      where?: InodeWhereInput;
      orderBy?: InodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Inode>;
  inodesConnection: (
    args?: {
      where?: InodeWhereInput;
      orderBy?: InodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InodeConnectionPromise;
  metadata: (where: MetadataWhereUniqueInput) => MetadataPromise;
  metadatas: (
    args?: {
      where?: MetadataWhereInput;
      orderBy?: MetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Metadata>;
  metadatasConnection: (
    args?: {
      where?: MetadataWhereInput;
      orderBy?: MetadataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MetadataConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  permissions: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Permission>;
  permissionsConnection: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PermissionConnectionPromise;
  permissionSet: (where: PermissionSetWhereUniqueInput) => PermissionSetPromise;
  permissionSets: (
    args?: {
      where?: PermissionSetWhereInput;
      orderBy?: PermissionSetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PermissionSet>;
  permissionSetsConnection: (
    args?: {
      where?: PermissionSetWhereInput;
      orderBy?: PermissionSetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PermissionSetConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createData: (data: DataCreateInput) => DataPromise;
  updateData: (
    args: { data: DataUpdateInput; where: DataWhereUniqueInput }
  ) => DataPromise;
  updateManyDatas: (
    args: { data: DataUpdateManyMutationInput; where?: DataWhereInput }
  ) => BatchPayloadPromise;
  upsertData: (
    args: {
      where: DataWhereUniqueInput;
      create: DataCreateInput;
      update: DataUpdateInput;
    }
  ) => DataPromise;
  deleteData: (where: DataWhereUniqueInput) => DataPromise;
  deleteManyDatas: (where?: DataWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (
    args: { data: GroupUpdateInput; where: GroupWhereUniqueInput }
  ) => GroupPromise;
  updateManyGroups: (
    args: { data: GroupUpdateManyMutationInput; where?: GroupWhereInput }
  ) => BatchPayloadPromise;
  upsertGroup: (
    args: {
      where: GroupWhereUniqueInput;
      create: GroupCreateInput;
      update: GroupUpdateInput;
    }
  ) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createInode: (data: InodeCreateInput) => InodePromise;
  updateInode: (
    args: { data: InodeUpdateInput; where: InodeWhereUniqueInput }
  ) => InodePromise;
  updateManyInodes: (
    args: { data: InodeUpdateManyMutationInput; where?: InodeWhereInput }
  ) => BatchPayloadPromise;
  upsertInode: (
    args: {
      where: InodeWhereUniqueInput;
      create: InodeCreateInput;
      update: InodeUpdateInput;
    }
  ) => InodePromise;
  deleteInode: (where: InodeWhereUniqueInput) => InodePromise;
  deleteManyInodes: (where?: InodeWhereInput) => BatchPayloadPromise;
  createMetadata: (data: MetadataCreateInput) => MetadataPromise;
  updateMetadata: (
    args: { data: MetadataUpdateInput; where: MetadataWhereUniqueInput }
  ) => MetadataPromise;
  updateManyMetadatas: (
    args: { data: MetadataUpdateManyMutationInput; where?: MetadataWhereInput }
  ) => BatchPayloadPromise;
  upsertMetadata: (
    args: {
      where: MetadataWhereUniqueInput;
      create: MetadataCreateInput;
      update: MetadataUpdateInput;
    }
  ) => MetadataPromise;
  deleteMetadata: (where: MetadataWhereUniqueInput) => MetadataPromise;
  deleteManyMetadatas: (where?: MetadataWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (
    args: { data: PermissionUpdateInput; where: PermissionWhereUniqueInput }
  ) => PermissionPromise;
  upsertPermission: (
    args: {
      where: PermissionWhereUniqueInput;
      create: PermissionCreateInput;
      update: PermissionUpdateInput;
    }
  ) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createPermissionSet: (data: PermissionSetCreateInput) => PermissionSetPromise;
  updatePermissionSet: (
    args: {
      data: PermissionSetUpdateInput;
      where: PermissionSetWhereUniqueInput;
    }
  ) => PermissionSetPromise;
  updateManyPermissionSets: (
    args: {
      data: PermissionSetUpdateManyMutationInput;
      where?: PermissionSetWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPermissionSet: (
    args: {
      where: PermissionSetWhereUniqueInput;
      create: PermissionSetCreateInput;
      update: PermissionSetUpdateInput;
    }
  ) => PermissionSetPromise;
  deletePermissionSet: (
    where: PermissionSetWhereUniqueInput
  ) => PermissionSetPromise;
  deleteManyPermissionSets: (
    where?: PermissionSetWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  data: (
    where?: DataSubscriptionWhereInput
  ) => DataSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  inode: (
    where?: InodeSubscriptionWhereInput
  ) => InodeSubscriptionPayloadSubscription;
  metadata: (
    where?: MetadataSubscriptionWhereInput
  ) => MetadataSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  permissionSet: (
    where?: PermissionSetSubscriptionWhereInput
  ) => PermissionSetSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "data_ASC"
  | "data_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NodeType = "FILE" | "DIRECTORY";

export type InodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MetadataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "parent_ASC"
  | "parent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionSetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "read_ASC"
  | "read_DESC"
  | "write_ASC"
  | "write_DESC"
  | "execute_ASC"
  | "execute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  data?: String;
  data_not?: String;
  data_in?: String[] | String;
  data_not_in?: String[] | String;
  data_lt?: String;
  data_lte?: String;
  data_gt?: String;
  data_gte?: String;
  data_contains?: String;
  data_not_contains?: String;
  data_starts_with?: String;
  data_not_starts_with?: String;
  data_ends_with?: String;
  data_not_ends_with?: String;
  AND?: DataWhereInput[] | DataWhereInput;
  OR?: DataWhereInput[] | DataWhereInput;
  NOT?: DataWhereInput[] | DataWhereInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export type InodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  metadata?: MetadataWhereInput;
  AND?: InodeWhereInput[] | InodeWhereInput;
  OR?: InodeWhereInput[] | InodeWhereInput;
  NOT?: InodeWhereInput[] | InodeWhereInput;
}

export interface MetadataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: UserWhereInput;
  group?: GroupWhereInput;
  permissions?: PermissionWhereInput;
  type?: NodeType;
  type_not?: NodeType;
  type_in?: NodeType[] | NodeType;
  type_not_in?: NodeType[] | NodeType;
  data_every?: DataWhereInput;
  data_some?: DataWhereInput;
  data_none?: DataWhereInput;
  parent?: String;
  parent_not?: String;
  parent_in?: String[] | String;
  parent_not_in?: String[] | String;
  parent_lt?: String;
  parent_lte?: String;
  parent_gt?: String;
  parent_gte?: String;
  parent_contains?: String;
  parent_not_contains?: String;
  parent_starts_with?: String;
  parent_not_starts_with?: String;
  parent_ends_with?: String;
  parent_not_ends_with?: String;
  AND?: MetadataWhereInput[] | MetadataWhereInput;
  OR?: MetadataWhereInput[] | MetadataWhereInput;
  NOT?: MetadataWhereInput[] | MetadataWhereInput;
}

export interface PermissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: PermissionSetWhereInput;
  group?: PermissionSetWhereInput;
  other?: PermissionSetWhereInput;
  AND?: PermissionWhereInput[] | PermissionWhereInput;
  OR?: PermissionWhereInput[] | PermissionWhereInput;
  NOT?: PermissionWhereInput[] | PermissionWhereInput;
}

export interface PermissionSetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  read?: Boolean;
  read_not?: Boolean;
  write?: Boolean;
  write_not?: Boolean;
  execute?: Boolean;
  execute_not?: Boolean;
  AND?: PermissionSetWhereInput[] | PermissionSetWhereInput;
  OR?: PermissionSetWhereInput[] | PermissionSetWhereInput;
  NOT?: PermissionSetWhereInput[] | PermissionSetWhereInput;
}

export type MetadataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PermissionSetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface DataCreateInput {
  data: String;
}

export interface DataUpdateInput {
  data?: String;
}

export interface DataUpdateManyMutationInput {
  data?: String;
}

export interface GroupCreateInput {
  name: String;
  users?: UserCreateManyInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
}

export interface GroupUpdateInput {
  name?: String;
  users?: UserUpdateManyInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  name?: String;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: String;
}

export interface GroupUpdateManyMutationInput {
  name?: String;
}

export interface InodeCreateInput {
  name: String;
  metadata: MetadataCreateOneInput;
}

export interface MetadataCreateOneInput {
  create?: MetadataCreateInput;
  connect?: MetadataWhereUniqueInput;
}

export interface MetadataCreateInput {
  owner: UserCreateOneInput;
  group: GroupCreateOneInput;
  permissions: PermissionCreateOneInput;
  type: NodeType;
  data?: DataCreateManyInput;
  parent?: String;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface GroupCreateOneInput {
  create?: GroupCreateInput;
  connect?: GroupWhereUniqueInput;
}

export interface PermissionCreateOneInput {
  create?: PermissionCreateInput;
  connect?: PermissionWhereUniqueInput;
}

export interface PermissionCreateInput {
  user: PermissionSetCreateOneInput;
  group: PermissionSetCreateOneInput;
  other: PermissionSetCreateOneInput;
}

export interface PermissionSetCreateOneInput {
  create?: PermissionSetCreateInput;
  connect?: PermissionSetWhereUniqueInput;
}

export interface PermissionSetCreateInput {
  read?: Boolean;
  write?: Boolean;
  execute?: Boolean;
}

export interface DataCreateManyInput {
  create?: DataCreateInput[] | DataCreateInput;
  connect?: DataWhereUniqueInput[] | DataWhereUniqueInput;
}

export interface InodeUpdateInput {
  name?: String;
  metadata?: MetadataUpdateOneRequiredInput;
}

export interface MetadataUpdateOneRequiredInput {
  create?: MetadataCreateInput;
  update?: MetadataUpdateDataInput;
  upsert?: MetadataUpsertNestedInput;
  connect?: MetadataWhereUniqueInput;
}

export interface MetadataUpdateDataInput {
  owner?: UserUpdateOneRequiredInput;
  group?: GroupUpdateOneRequiredInput;
  permissions?: PermissionUpdateOneRequiredInput;
  type?: NodeType;
  data?: DataUpdateManyInput;
  parent?: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GroupUpdateOneRequiredInput {
  create?: GroupCreateInput;
  update?: GroupUpdateDataInput;
  upsert?: GroupUpsertNestedInput;
  connect?: GroupWhereUniqueInput;
}

export interface GroupUpdateDataInput {
  name?: String;
  users?: UserUpdateManyInput;
}

export interface GroupUpsertNestedInput {
  update: GroupUpdateDataInput;
  create: GroupCreateInput;
}

export interface PermissionUpdateOneRequiredInput {
  create?: PermissionCreateInput;
  update?: PermissionUpdateDataInput;
  upsert?: PermissionUpsertNestedInput;
  connect?: PermissionWhereUniqueInput;
}

export interface PermissionUpdateDataInput {
  user?: PermissionSetUpdateOneRequiredInput;
  group?: PermissionSetUpdateOneRequiredInput;
  other?: PermissionSetUpdateOneRequiredInput;
}

export interface PermissionSetUpdateOneRequiredInput {
  create?: PermissionSetCreateInput;
  update?: PermissionSetUpdateDataInput;
  upsert?: PermissionSetUpsertNestedInput;
  connect?: PermissionSetWhereUniqueInput;
}

export interface PermissionSetUpdateDataInput {
  read?: Boolean;
  write?: Boolean;
  execute?: Boolean;
}

export interface PermissionSetUpsertNestedInput {
  update: PermissionSetUpdateDataInput;
  create: PermissionSetCreateInput;
}

export interface PermissionUpsertNestedInput {
  update: PermissionUpdateDataInput;
  create: PermissionCreateInput;
}

export interface DataUpdateManyInput {
  create?: DataCreateInput[] | DataCreateInput;
  update?:
    | DataUpdateWithWhereUniqueNestedInput[]
    | DataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DataUpsertWithWhereUniqueNestedInput[]
    | DataUpsertWithWhereUniqueNestedInput;
  delete?: DataWhereUniqueInput[] | DataWhereUniqueInput;
  connect?: DataWhereUniqueInput[] | DataWhereUniqueInput;
  set?: DataWhereUniqueInput[] | DataWhereUniqueInput;
  disconnect?: DataWhereUniqueInput[] | DataWhereUniqueInput;
  deleteMany?: DataScalarWhereInput[] | DataScalarWhereInput;
  updateMany?:
    | DataUpdateManyWithWhereNestedInput[]
    | DataUpdateManyWithWhereNestedInput;
}

export interface DataUpdateWithWhereUniqueNestedInput {
  where: DataWhereUniqueInput;
  data: DataUpdateDataInput;
}

export interface DataUpdateDataInput {
  data?: String;
}

export interface DataUpsertWithWhereUniqueNestedInput {
  where: DataWhereUniqueInput;
  update: DataUpdateDataInput;
  create: DataCreateInput;
}

export interface DataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  data?: String;
  data_not?: String;
  data_in?: String[] | String;
  data_not_in?: String[] | String;
  data_lt?: String;
  data_lte?: String;
  data_gt?: String;
  data_gte?: String;
  data_contains?: String;
  data_not_contains?: String;
  data_starts_with?: String;
  data_not_starts_with?: String;
  data_ends_with?: String;
  data_not_ends_with?: String;
  AND?: DataScalarWhereInput[] | DataScalarWhereInput;
  OR?: DataScalarWhereInput[] | DataScalarWhereInput;
  NOT?: DataScalarWhereInput[] | DataScalarWhereInput;
}

export interface DataUpdateManyWithWhereNestedInput {
  where: DataScalarWhereInput;
  data: DataUpdateManyDataInput;
}

export interface DataUpdateManyDataInput {
  data?: String;
}

export interface MetadataUpsertNestedInput {
  update: MetadataUpdateDataInput;
  create: MetadataCreateInput;
}

export interface InodeUpdateManyMutationInput {
  name?: String;
}

export interface MetadataUpdateInput {
  owner?: UserUpdateOneRequiredInput;
  group?: GroupUpdateOneRequiredInput;
  permissions?: PermissionUpdateOneRequiredInput;
  type?: NodeType;
  data?: DataUpdateManyInput;
  parent?: String;
}

export interface MetadataUpdateManyMutationInput {
  type?: NodeType;
  parent?: String;
}

export interface PermissionUpdateInput {
  user?: PermissionSetUpdateOneRequiredInput;
  group?: PermissionSetUpdateOneRequiredInput;
  other?: PermissionSetUpdateOneRequiredInput;
}

export interface PermissionSetUpdateInput {
  read?: Boolean;
  write?: Boolean;
  execute?: Boolean;
}

export interface PermissionSetUpdateManyMutationInput {
  read?: Boolean;
  write?: Boolean;
  execute?: Boolean;
}

export interface UserUpdateInput {
  name?: String;
}

export interface UserUpdateManyMutationInput {
  name?: String;
}

export interface DataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DataWhereInput;
  AND?: DataSubscriptionWhereInput[] | DataSubscriptionWhereInput;
  OR?: DataSubscriptionWhereInput[] | DataSubscriptionWhereInput;
  NOT?: DataSubscriptionWhereInput[] | DataSubscriptionWhereInput;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface InodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InodeWhereInput;
  AND?: InodeSubscriptionWhereInput[] | InodeSubscriptionWhereInput;
  OR?: InodeSubscriptionWhereInput[] | InodeSubscriptionWhereInput;
  NOT?: InodeSubscriptionWhereInput[] | InodeSubscriptionWhereInput;
}

export interface MetadataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MetadataWhereInput;
  AND?: MetadataSubscriptionWhereInput[] | MetadataSubscriptionWhereInput;
  OR?: MetadataSubscriptionWhereInput[] | MetadataSubscriptionWhereInput;
  NOT?: MetadataSubscriptionWhereInput[] | MetadataSubscriptionWhereInput;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionWhereInput;
  AND?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  OR?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  NOT?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
}

export interface PermissionSetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionSetWhereInput;
  AND?:
    | PermissionSetSubscriptionWhereInput[]
    | PermissionSetSubscriptionWhereInput;
  OR?:
    | PermissionSetSubscriptionWhereInput[]
    | PermissionSetSubscriptionWhereInput;
  NOT?:
    | PermissionSetSubscriptionWhereInput[]
    | PermissionSetSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Data {
  id: ID_Output;
  data: String;
}

export interface DataPromise extends Promise<Data>, Fragmentable {
  id: () => Promise<ID_Output>;
  data: () => Promise<String>;
}

export interface DataSubscription
  extends Promise<AsyncIterator<Data>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  data: () => Promise<AsyncIterator<String>>;
}

export interface DataConnection {
  pageInfo: PageInfo;
  edges: DataEdge[];
}

export interface DataConnectionPromise
  extends Promise<DataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataEdge>>() => T;
  aggregate: <T = AggregateDataPromise>() => T;
}

export interface DataConnectionSubscription
  extends Promise<AsyncIterator<DataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DataEdge {
  node: Data;
  cursor: String;
}

export interface DataEdgePromise extends Promise<DataEdge>, Fragmentable {
  node: <T = DataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataEdgeSubscription
  extends Promise<AsyncIterator<DataEdge>>,
    Fragmentable {
  node: <T = DataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateData {
  count: Int;
}

export interface AggregateDataPromise
  extends Promise<AggregateData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataSubscription
  extends Promise<AsyncIterator<AggregateData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Group {
  id: ID_Output;
  name: String;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Inode {
  id: ID_Output;
  name: String;
}

export interface InodePromise extends Promise<Inode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  metadata: <T = MetadataPromise>() => T;
}

export interface InodeSubscription
  extends Promise<AsyncIterator<Inode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  metadata: <T = MetadataSubscription>() => T;
}

export interface Metadata {
  id: ID_Output;
  type: NodeType;
  parent?: String;
}

export interface MetadataPromise extends Promise<Metadata>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  group: <T = GroupPromise>() => T;
  permissions: <T = PermissionPromise>() => T;
  type: () => Promise<NodeType>;
  data: <T = FragmentableArray<Data>>(
    args?: {
      where?: DataWhereInput;
      orderBy?: DataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parent: () => Promise<String>;
}

export interface MetadataSubscription
  extends Promise<AsyncIterator<Metadata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  group: <T = GroupSubscription>() => T;
  permissions: <T = PermissionSubscription>() => T;
  type: () => Promise<AsyncIterator<NodeType>>;
  data: <T = Promise<AsyncIterator<DataSubscription>>>(
    args?: {
      where?: DataWhereInput;
      orderBy?: DataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parent: () => Promise<AsyncIterator<String>>;
}

export interface Permission {
  id: ID_Output;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = PermissionSetPromise>() => T;
  group: <T = PermissionSetPromise>() => T;
  other: <T = PermissionSetPromise>() => T;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = PermissionSetSubscription>() => T;
  group: <T = PermissionSetSubscription>() => T;
  other: <T = PermissionSetSubscription>() => T;
}

export interface PermissionSet {
  id: ID_Output;
  read: Boolean;
  write: Boolean;
  execute: Boolean;
}

export interface PermissionSetPromise
  extends Promise<PermissionSet>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  read: () => Promise<Boolean>;
  write: () => Promise<Boolean>;
  execute: () => Promise<Boolean>;
}

export interface PermissionSetSubscription
  extends Promise<AsyncIterator<PermissionSet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  read: () => Promise<AsyncIterator<Boolean>>;
  write: () => Promise<AsyncIterator<Boolean>>;
  execute: () => Promise<AsyncIterator<Boolean>>;
}

export interface InodeConnection {
  pageInfo: PageInfo;
  edges: InodeEdge[];
}

export interface InodeConnectionPromise
  extends Promise<InodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InodeEdge>>() => T;
  aggregate: <T = AggregateInodePromise>() => T;
}

export interface InodeConnectionSubscription
  extends Promise<AsyncIterator<InodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInodeSubscription>() => T;
}

export interface InodeEdge {
  node: Inode;
  cursor: String;
}

export interface InodeEdgePromise extends Promise<InodeEdge>, Fragmentable {
  node: <T = InodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InodeEdgeSubscription
  extends Promise<AsyncIterator<InodeEdge>>,
    Fragmentable {
  node: <T = InodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInode {
  count: Int;
}

export interface AggregateInodePromise
  extends Promise<AggregateInode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInodeSubscription
  extends Promise<AsyncIterator<AggregateInode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetadataConnection {
  pageInfo: PageInfo;
  edges: MetadataEdge[];
}

export interface MetadataConnectionPromise
  extends Promise<MetadataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetadataEdge>>() => T;
  aggregate: <T = AggregateMetadataPromise>() => T;
}

export interface MetadataConnectionSubscription
  extends Promise<AsyncIterator<MetadataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetadataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetadataSubscription>() => T;
}

export interface MetadataEdge {
  node: Metadata;
  cursor: String;
}

export interface MetadataEdgePromise
  extends Promise<MetadataEdge>,
    Fragmentable {
  node: <T = MetadataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetadataEdgeSubscription
  extends Promise<AsyncIterator<MetadataEdge>>,
    Fragmentable {
  node: <T = MetadataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMetadata {
  count: Int;
}

export interface AggregateMetadataPromise
  extends Promise<AggregateMetadata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetadataSubscription
  extends Promise<AsyncIterator<AggregateMetadata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionSetConnection {
  pageInfo: PageInfo;
  edges: PermissionSetEdge[];
}

export interface PermissionSetConnectionPromise
  extends Promise<PermissionSetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionSetEdge>>() => T;
  aggregate: <T = AggregatePermissionSetPromise>() => T;
}

export interface PermissionSetConnectionSubscription
  extends Promise<AsyncIterator<PermissionSetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionSetEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSetSubscription>() => T;
}

export interface PermissionSetEdge {
  node: PermissionSet;
  cursor: String;
}

export interface PermissionSetEdgePromise
  extends Promise<PermissionSetEdge>,
    Fragmentable {
  node: <T = PermissionSetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionSetEdgeSubscription
  extends Promise<AsyncIterator<PermissionSetEdge>>,
    Fragmentable {
  node: <T = PermissionSetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermissionSet {
  count: Int;
}

export interface AggregatePermissionSetPromise
  extends Promise<AggregatePermissionSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSetSubscription
  extends Promise<AsyncIterator<AggregatePermissionSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DataSubscriptionPayload {
  mutation: MutationType;
  node: Data;
  updatedFields: String[];
  previousValues: DataPreviousValues;
}

export interface DataSubscriptionPayloadPromise
  extends Promise<DataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataPreviousValuesPromise>() => T;
}

export interface DataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataPreviousValuesSubscription>() => T;
}

export interface DataPreviousValues {
  id: ID_Output;
  data: String;
}

export interface DataPreviousValuesPromise
  extends Promise<DataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  data: () => Promise<String>;
}

export interface DataPreviousValuesSubscription
  extends Promise<AsyncIterator<DataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  data: () => Promise<AsyncIterator<String>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  name: String;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface InodeSubscriptionPayload {
  mutation: MutationType;
  node: Inode;
  updatedFields: String[];
  previousValues: InodePreviousValues;
}

export interface InodeSubscriptionPayloadPromise
  extends Promise<InodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InodePreviousValuesPromise>() => T;
}

export interface InodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InodePreviousValuesSubscription>() => T;
}

export interface InodePreviousValues {
  id: ID_Output;
  name: String;
}

export interface InodePreviousValuesPromise
  extends Promise<InodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface InodePreviousValuesSubscription
  extends Promise<AsyncIterator<InodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MetadataSubscriptionPayload {
  mutation: MutationType;
  node: Metadata;
  updatedFields: String[];
  previousValues: MetadataPreviousValues;
}

export interface MetadataSubscriptionPayloadPromise
  extends Promise<MetadataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetadataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetadataPreviousValuesPromise>() => T;
}

export interface MetadataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetadataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetadataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetadataPreviousValuesSubscription>() => T;
}

export interface MetadataPreviousValues {
  id: ID_Output;
  type: NodeType;
  parent?: String;
}

export interface MetadataPreviousValuesPromise
  extends Promise<MetadataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<NodeType>;
  parent: () => Promise<String>;
}

export interface MetadataPreviousValuesSubscription
  extends Promise<AsyncIterator<MetadataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<NodeType>>;
  parent: () => Promise<AsyncIterator<String>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PermissionPreviousValues {
  id: ID_Output;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PermissionSetSubscriptionPayload {
  mutation: MutationType;
  node: PermissionSet;
  updatedFields: String[];
  previousValues: PermissionSetPreviousValues;
}

export interface PermissionSetSubscriptionPayloadPromise
  extends Promise<PermissionSetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionSetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionSetPreviousValuesPromise>() => T;
}

export interface PermissionSetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionSetPreviousValuesSubscription>() => T;
}

export interface PermissionSetPreviousValues {
  id: ID_Output;
  read: Boolean;
  write: Boolean;
  execute: Boolean;
}

export interface PermissionSetPreviousValuesPromise
  extends Promise<PermissionSetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  read: () => Promise<Boolean>;
  write: () => Promise<Boolean>;
  execute: () => Promise<Boolean>;
}

export interface PermissionSetPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionSetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  read: () => Promise<AsyncIterator<Boolean>>;
  write: () => Promise<AsyncIterator<Boolean>>;
  execute: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "PermissionSet",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "NodeType",
    embedded: false
  },
  {
    name: "Data",
    embedded: false
  },
  {
    name: "Inode",
    embedded: false
  },
  {
    name: "Metadata",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
